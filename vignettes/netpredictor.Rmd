---
title: "NetPredictor"
author: "Abhik Seal"
date: "`r Sys.Date()`"
output:
  rmarkdown::pdf_document:
      fig_caption: yes
vignette: >
  %\VignetteIndexEntry{netpredictor tutorial}
  %\VignetteEngine{knitr::knitr}
  %\usepackage[utf8]{inputenc}
---

## Table of Contents

[1. Introduction](#introduction)

[2. Installation](#installation)

[3. Examples](#Examples)

[4. Analyzing Results](#analzying-results)

[5. Citations](#citations)

_______

## 1. Introduction
Social and biological systems can be represented by graphs where nodes represent individuals ,biological experiments(protein,genes,etc.) web users and so on. Networks allows methods of graph theory to be applied to the task of predicting links. Link prediction predicts missing links in networks or links in future networks, it is also important for mining and analyzing the evolution of networks. Link prediction problem is a long-standing challenge in modern information science, and a lot of algorithms based on Markov chains and statistical models have been proposed by computer science community. The link prediction problem is usually defined in unipartite graphs. The netpredictor package is developed to solve the problem of bipartite link prediction using Random walk with restart(RWR) and network based inference methods(NBI). We plan to integrate varierty of other algorithms in near future. All of the code is developed in R which also provides parallel execution modes. 

Consider an undirected, unweighted network $G = (V, E)$, where V is the set of nodes and E is the set of links. For each pair of nodes  \{$a$,$b$} $\in$ V  we can assign a proximity score by executing the random walk procedure as follows : 

- we start a random walker from a. 
- At each time step, with the probability $1-c$, the walker walks to one of the neighbors, $b$, according to the transition probability matrix  $W_{ab} = \frac{S_{ab}}{T}$  where $S_{ab}$ is the adjacency matrix of the network and ($S_{ab}$ equals 1 if node a and b are connected, 0 otherwise) $K_{a}$  denotes the degree of a.
- With the probability c, the walker goes back to a. 
- After many time steps the probability of finding the random walker at node x converges to the steady-state probability, which is our proximity score $S_{a \rightarrow x}$.

One of the most widely used ways to solve random walk with restart is the matrix iteration method, iterating the equation (1) until convergence, i.e, until the L2 norm of successive estimates of below our threshold T $10 ^ {-7}$.
\begin{equation}
\begin{aligned}
P_{t+1} = ( 1 - c ) W^{T} P_{t} + cP_{0}
\end{aligned}
\end{equation}

_______

## 2. Installation

A stable tested version of SAGA is available from the CRAN repository or the most recent version may be installed from github using the devtools package: 

Installing from github

     install.packages("devtools")
     install_github("abhik1368/netpredicter")     

_______

## 3. Examples
Here at first we look at the properties which can be calculated on unipartite graphs.

```{r, eval=FALSE,results='asis'}

require(igraph)
require(netpredictor)
g1 <- upgrade_graph(erdos.renyi.game(100, 1/100))
V(g1)$name <- seq(1,100,1)
score_mat <- unetSim(g1,"aa")
head(which(score_mat!=0, arr.ind = T))

## Common neighbors vertex similarity
score_mat <- unetSim(g1,"cn")
head(which(score_mat!=0, arr.ind = T))

## Jaccard Index similarity

score_mat <- unetSim(g1,"jc")

## Dice similarity

score_mat <- unetSim(g1,"dice")

## Katz Index similarity

score_mat <- unetSim(g1,"katz")

## Geodesic distance vertex similarity

score_mat <- unetSim(g1,"dist")

## Cosine vertex similarity/ Salton index

score_mat <- unetSim(g1,"cosine")

## Preferential attachment vertex similarity

score_mat <- unetSim(g1,"pa")

## Local Paths Index
## This function counts the number of two-paths and three-paths between nodes,
#  with three-paths weighted by a parameter \eqn{\epsilon}.

score_lpsim <- unetSim(g1,"lp")

## Hub promoted Index
## This measures assigns higher scores to links adjacent to hubs (high degree nodes). It 
## counts common neighbors of two vertices and weigths the result.

score_hpsim <- unetSim(g1,"hpi")

## Similarity measure based on resource allocation process (number of common neighbours 
## weighted by the inverse of their degrees)

score_hpsim <- unetSim(g1,"ra")
```


Next we look at the properties which can be calculated on Bipartite graphs.

```{r, eval=FALSE,results='asis'}


suppressPackageStartupMessages(library(igraph))
suppressPackageStartupMessages(library(netpredictor))
## dataset enzyme is provide in netpredictor package
data(Enzyme)

## Get the Enzyme and compound adjacency matrix
A <- t(enzyme_ADJ)

## degree Centrality of the Bipartite Graph
get.biDegreeCentrality(A)

## Compute Graph density of Bipartite Graph
get.biDensity(A)

## Compute betweeness centrality of Bipartite Graph
get.biBetweenessCentrality(A)

## Projects Bipartite Networks into monopartite networks default method is shared 
## neighbours.
get.biWeightedProjection(A)

```

Next we will use the different methods to predict links. Here we have shown examples based on drug target prediction. With the growing understanding of complex diseases, the focus of drug discovery has shifted away from "one target, one drug" model, to a new "multi-target, multi-drug" model. Predicting potential drug-target interactions from heterogeneous biological data is critical not only for better understanding of the various interactions and biological processes, but also for the development of novel drugs and the improvement of human medicines. To predict polypharmacology people use bayesian methods, SVM and Random Forest models, but in all of those algorithms the methods depends on labelled data to predict unknown links. Network based approaches does not rely on labelled data . Two of the algorihtms implemented in this package Random walk based Restart(RWR) and Network based Inference(NBI) to do it. For performing RWR we used Drug target network which is a bipartite graph in which every links connects drugs to proteins. 

```{r, eval= TRUE,results='asis' ,messages=FALSE}
suppressPackageStartupMessages(require(igraph))
suppressPackageStartupMessages(require(netpredictor))

## We use the enzyme data provided in the netpredictor package. The example
# below shows how to perform random walk with restart

data(Enzyme)
## load the adjacency matrix 
A <- enzyme_ADJ 

## load the chemical similarity matrix calculated from other packages or softwares
S2 = enzyme_Csim 

## load the protein similarity matrix

S1 = enzyme_Gsim

## Convert the adjacency matrix to igraph object because biNetwalk function used igraph object
g1 = graph.incidence(A)

## Run the RWR in bipartite network.
pScore <- biNetwalk(g1,s1=S1,s2=S2,normalise="laplace", dataSeed=NULL,
                restart=0.8, parallel=TRUE, multicores=NULL, verbose=T)

dim(pScore)
```

In this example we attempt to use the dataseed file which contains the pairs relations between targets and drugs. This can be useful when one is trying to investigate relations for a specific set of relations . The Drug names and proteins names should be included in the adjacency matrix when one uses the file option to provide dataseed. In the dataseed file the first column contains the proteins names and the second column the drug names. Ouput is a matrix of unique drugs against the number of targets in the adjacency matrix. 


```{r, eval= TRUE,results='asis' ,messages=TRUE}

suppressPackageStartupMessages(require(igraph))
suppressPackageStartupMessages(require(netpredictor))
library(printr)
data(Enzyme)

A <- t(enzyme_ADJ)
g1 <- upgrade_graph(graph.incidence(A,mode = 'all')) 
S1 = enzyme_Csim 
S2 = enzyme_Gsim
## Read the dataseed file from the user 
dataF<- read.csv("seedFile.csv",header=FALSE)
knitr::kable(dataF)
Mat <- biNetwalk(g1,s1=S1,s2=S2,normalise="laplace", dataSeed =dataF,
                 restart=0.8,parallel=TRUE, multicores=NULL, verbose=T)
dim(Mat)


```

In this next example we will see how we can plot the significant communities of drugs from the final RWR computed matrix. We also input a list of drugs as vector and retrieve top 10 interactions for each of those drugs. In this package after getting the results one can easily write the results in GML format for visualization in Gephi or cytoscape. It also support export to GEXF format to Gephi specific file format. Below shows the example of exporting to GML format.

```{r, eval= TRUE,results='asis' ,messages=TRUE,warning=FALSE}

suppressPackageStartupMessages(require(igraph))
suppressPackageStartupMessages(require(netpredictor))

A <- enzyme_ADJ 
S1 = enzyme_Gsim
S2 = enzyme_Csim
g1 = graph.incidence(A)
Q = biNetwalk(g1,s1=S1,s2=S2,normalise="laplace",dataSeed=NULL,restart=0.8,
              parallel=TRUE,multicores=NULL, verbose=T)

## Get the top results of RWR prediction. This function returns the associations     
## of drugs and target names with scores and type interaction whether
## True / predicted interactions.

knitr::kable(head(getTopresults(A,Q,top=10,druglist=NULL)))

## Get top results of RWR prediction using a list of drug names. One should be careful using 
## a drug list it should contain drug names which are in the adjacency matrix.     

drugs = c("D00014","D00018", "D00029", "D00036","D00045","D00049")
result <- getTopresults(A,Q,top=10,druglist=drugs)

## Get the results
head(result)

## Save the top results in GML format for visualization in Gephi.
g<-graph.data.frame(result[,1:2],directed=FALSE)
g <- set.edge.attribute(g, "weight", value=result[,3])
saveGML(g,"netresult.gml","netresult")

## Get the significance graph 
Z = sig.net(data=A,g=g1,Amatrix=Q,num.permutation=100,adjp.cutoff=0.01,
            p.adjust.method="BH",parallel=FALSE)

## Get the graph for plotting commnuties
g <- Z$cgraph

gp <- get.Communities(g)

## Get members from the first community
print(gp[[1]]$community)

## Total number of communities
length(gp)

## Plot the communities with 5 columns
plot_Community(gp,cols=5)

```

One can use net.perf function it samples and removes links from the adjacency matrix and predicts them and calculates area under accumulation curve, AUC, bedroc, and Enrichment factor. In the example below we remove 50 links and repredict those links. While repredicting  them we calculate performance metrics like AUC,bedroc and enrichment factor. As the number of links (relinks) increases the performance of prediction drops. 'Calgo' option uses different algorithms like "nbi" ,"rwr" and "netcombo" . 

```{r, eval= TRUE,results='asis' ,messages=TRUE,warning=FALSE}

data(Enzyme)
A = enzyme_ADJ 
S1 = enzyme_Gsim 
S2= enzyme_Csim

m = net.perf(A,S1,S2,relinks = 50,numT=2,Calgo="nbi")
m

```


_______

## 4. Analzying Results


_______

## 6. Citations
[1] Kohler S, et al. Walking the Interactome for Prioritization of Candidate Disease Genes. American Journal of Human Genetics. 2008;82:949–958.

[2] Can, T., Camoglu, O., and Singh, A.K. (2005). Analysis of protein-protein interaction networks using random walks. In BIOKDD '05: Proceedings of the 5th international workshop on Bioinformatics (New York, USA: Association for Computing Machinery). 61–68

[3] Cheng F, et al. Prediction of drug-target interactions and drug repositioning via network-based inference. PLoS Comput. Biol. 2012;8:e1002503.

[4] Zhou T, et al. Solving the apparent diversity-accuracy dilemma of recommender systems. Proc. Natl Acad. Sci. USA 2010;107:4511-4515.

[5] Zhou T, et al. Bipartite network projection and personal recommendation. Phys. Rev. E Stat. Nonlin. Soft Matter Phys. 2007;76:046115.

[6] http://data2quest.blogspot.com/2015/02/link-prediction-using-network-based.html

[7] Vanunu O, Sharan R. Proceedings of the German Conference on Bioinformatics. Germany: GI; 2008. A propagation-based algorithm for inferring gene-disease assocations; pp. 54–63.

[8] Chen X, et al. Drug–target interaction prediction by random walk on the heterogeneous network. Mol. BioSyst 2012;8:1970-1978

[9] Seal  A, Ahn  Y, Wild  DJ . Optimizing drug&#8211;target interaction prediction based on random walk on heterogeneous networks Journal of Cheminformatics 2015, 7:40.

[10] Truchon et al. Evaluating Virtual Screening Methods: Good and Bad Metrics for the "Early Recognition" Problem. J. Chem. Inf. Model. (2007) 47, 488-508.

[11] Sheridan RP et al. Protocols for bridging the peptide to nonpeptide gap in topological similarity searches. J. Chem. Inf. Comput. Sci. (2001) 41, 1395-1406.
